#!/usr/bin/env ruby
# Wrapper for pushing to remote
# - Will init the upstream branch on first push
# - Will allow user to specify a remote and a branch (default to origin and
#   current branch)
# - Is clever about what is specified : branch or remote
#
# Usage :
# $ git-remote-push
# $ git-remote-push remote (current_branch)
# $ git-remote-push (origin) branch
# $ git-remote-push remote branch

class GitRemotePush

  def initialize(*args)
    @flags = []
    @args = []

    # Split --flags and real options
    ARGV.each do |arg|
      if arg =~ /^-/
        @flags << arg
      else
        @args << arg
      end
    end

    # No args, default origin and default branch
    if @args.size == 0
      @remoteName = "origin"
      @branchName = current_branch
    end

    # Two args, both remote and branch
    if @args.size == 2
      @remoteName = @args[0]
      @branchName = @args[1]
    end

    # Only one args, it can either be a branch, or a remote
    if @args.size == 1
      if is_remote @args[0]
        @remoteName = @args[0]
        @branchName = current_branch
      else
        @remoteName = "origin"
        @branchName = @args[0]
      end
    end
  end

  def current_branch
    %x[git current-branch].strip
  end

  def first_push?
    %x[git config "branch.#{@branchName}.merge"].strip == ''
  end

  def is_remote(name)
    system("git remote-exists #{name}")
  end

  def run
    command_args=@flags
    # Setting remote
    if first_push?
      command_args << "--set-upstream #{@remoteName}"
    else
      command_args << @remoteName
    end
    # Setting branch
    command_args << @branchName

    system("git push #{command_args.join(' ')}")
    # Fetching remote to be up to date
    %x[git fetch]
  end

end
GitRemotePush.new(*ARGV).run()
